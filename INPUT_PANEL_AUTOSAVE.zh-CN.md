# Codex 分类强制双区域 + 同步编辑栏 + 2 秒自动保存（本地存储）方案

## 目标

在 Codex 分类下（包含“新建模版”和“修改配置”两种场景），页面必须固定提供两个区域，避免只有小信息框导致粘贴/编辑困难：

- 左侧：原有信息框/表单区域（可能是 1 个信息框，也可能是 2 个信息框：`config.toml` / `auth.json`）
- 右侧：大文本同步编辑区（与左侧双向同步、实时一致）
- 默认进入 Codex 页面就展示双区域（不要求用户先点“展开”）
- 无“保存”按钮；用户停止输入 2 秒后自动保存
- 自动保存结果写入本地（下次打开自动恢复），便于你后续获取/排障

---

## 交互与布局

### 入口按钮（可选：用于临时收起右侧编辑区）

- 位置：页面顶部工具栏右侧（或右侧面板标题栏）。
- 状态：
  - 展开状态：按钮文案 `收起编辑`
  - 收起状态：按钮文案 `展开编辑`
- 记忆：
  - Codex 分类的默认值应为 `panelOpen=true`
  - 允许用户收起后持久化（下次仍收起），但建议提供“一键恢复默认布局”

### 布局形态（推荐：左右分栏）

- 默认：左侧为原有信息框区域；右侧为“同步编辑栏”（默认打开）。
- 默认比例：左右各占 50% 宽度。
- 可选增强：中间加拖拽分隔条（用户可调比例；比例也可本地持久化）。

（如果你的页面更适合纵向空间，也可以做“上下分栏”，其余逻辑不变。）

---

## 同步策略（Codex 分类：一个信息框 vs 两个信息框）

核心原则：左侧信息框和右侧编辑区不应该各自维护一份数据；应当共享同一个“单一数据源（single source of truth）”，避免互相覆盖/光标抖动。

### 情况 A：一个信息框

- 数据模型：
  - `text: string`
- 左侧信息框的 `v-model` 绑定 `text`
- 右侧编辑器的 `v-model` 也绑定 `text`
- 这样左右天然同步，不需要手写“从左复制到右”的逻辑

### 情况 B：两个信息框（config.toml + auth.json）

推荐右侧编辑栏提供“Tab/分段切换”来编辑当前焦点内容：

- 数据模型：
  - `configText: string`
  - `authText: string`
  - `active: 'config' | 'auth'`
- 左侧：两个信息框各自绑定各自的字段
- 右侧：根据 `active` 显示同一个编辑器，但 `v-model` 绑定到对应字段
- 额外同步体验（建议做）：
  - 当用户点击左侧某个信息框时，右侧 `active` 自动切到对应项
  - 当右侧切换 Tab 时，可将焦点也切到左侧对应信息框（可选）

---

## 自动保存（2 秒无输入即保存）

### 触发规则

- 用户每次输入（左侧或右侧任一处）都会触发“变更”。
- 使用 debounce：
  - 在最后一次输入后的 2000ms 执行一次保存
  - 在 2000ms 内持续输入则重置计时
- 页面关闭/切换时的兜底：
  - `beforeunload` / 路由离开 / 窗口关闭前，若有未落盘变更，立刻保存一次（不等 2 秒）

### 保存状态提示（建议）

避免用户疑惑“到底保存了没”，可在按钮旁加一个很轻量的状态：

- `已保存` / `保存中...` / `保存失败（点击重试）`

---

## 本地存储方式（推荐 Electron：写入 userData）

你希望“存储到本地给我”，通常有两种实现路线：

### 方案 1（推荐）：主进程落盘到 `app.getPath('userData')`

适合：Electron 应用；需要稳定、可控的本地文件；不依赖浏览器存储上限。

- Renderer 侧：只负责发 IPC 调用（如 `settings:saveDraft`）
- Main 侧：把草稿写到 `userData` 目录，例如：
  - `%APPDATA%/<YourApp>/drafts/codex-input.json`
- 优点：
  - 容量/稳定性更好
  - 你可以很明确地告诉用户“草稿文件在哪”，方便用户打包给你

建议落盘结构（示例）：

```json
{
  "version": 1,
  "updatedAt": "2026-01-25T12:34:56.000Z",
  "layout": { "panelOpen": true, "split": 0.5, "active": "config" },
  "draft": {
    "singleText": "",
    "configToml": "",
    "authJson": ""
  }
}
```

### 方案 2：Renderer 使用 `localStorage/IndexedDB`

适合：纯 Web 或你不想走 IPC。

- 优点：实现很快
- 缺点：受浏览器策略/容量影响；不易定位文件给你；跨设备迁移不方便

如果你明确需要“用户把本地文件发给你”，还是更推荐方案 1。

---

## 关键边界与细节

- 大文本性能：编辑器组件建议用 `textarea` 起步，后续再换 CodeMirror/Monaco（避免早期复杂度）。
- 同步光标：左右同源绑定时不要做“watch A -> set B”的互设；否则容易出现光标跳动、输入法候选中断。
- JSON/TOML 校验：
  - 可在右侧编辑栏底部显示“格式校验结果”（非阻塞）
  - 自动保存不必强制要求通过校验（避免用户半输入时保存失败）
- 安全提醒：
  - 如果内容可能包含 token/key，建议在 UI 中提示“请脱敏”
  - 或提供“一键脱敏”按钮（把常见键名对应值替换为 `***REDACTED***`）

---

## 实施步骤（落地清单）

1) 新增 UI：Codex 分类默认双区域（分栏布局）+ 可选“收起/展开”按钮
2) 抽象状态模型：
   - 一个信息框：`text`
   - 两个信息框：`configText/authText + active`
3) 接入 debounce 自动保存（2 秒）+ 离开前强制保存
4) 本地存储实现：
   - Electron：Renderer -> IPC -> Main 写入 `userData` 下的草稿文件
5) 启动时读取草稿恢复 UI（含 panelOpen、split、active）
6) 加“保存状态提示”（已保存/保存中/失败）



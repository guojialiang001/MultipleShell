 ---
  问题与风险

  1. 过度抽象，配置膨胀严重

  EffectiveProxyPolicy 类型有 30+ 个字段，模板新增选项有 10 个（4.1.1 节表格）。对一个"代理 +
  熔断"功能来说，这个配置面太大了。实际使用时大部分用户只需要：

  - 是否走代理
  - 队列是什么
  - 熔断参数用默认值

  建议：先只暴露 2-3 个用户可见选项（proxyEnabled +
  proxyImplementation），其余全部用合理默认值内部处理，不作为模板字段。

  2. respectCCSwitchProxyConfig 语义容易混淆

  把 CC Switch Proxy 的配置表（proxy_config）复用为 app-proxy 的"运营开关"，文档自己在 5.6.1
  末尾也提到了这个风险。这种"借用别人的字段控制自己的行为"会导致：

  - CC Switch 侧改了 enabled 本意是控制自己的 proxy，却意外关掉了应用的 proxy
  - 两个系统的操作人员可能不是同一个人

  建议：如果需要远程开关，应该在 CC Switch 中新增独立字段（如 app_proxy_enabled），而非复用现有字段。

  3. 队列构建逻辑（5.5.2）中 primary 选择过于复杂

  4 级 fallback（requestedProviderId → currentProviderId → is_current=true → providers[0]）增加了排查难度。建议简化 2
  级：用户指定 > CC Switch current，其余情况直接用队列首位。

  4. 缺少热更新和生命周期管理的讨论

  - CC Switch 快照变化后（provider 增删、enabled 开关切换），正在运行的 proxy 如何感知？需要轮询还是推送？
  - 队列变更时正在进行的请求如何处理？
  - Proxy 端口冲突、启动失败时的错误处理和用户提示

  这些是落地时必须解决的问题，但文档没有涉及。

  5. 多协议兼容性被低估

  5.5.1 提到队列内 provider 需要"同协议、同接口能力、同模型命名"，但只给了"运营约束"这个建议。实际上这是 failover
  能否真正"无感"的核心前提条件。如果队列里混入了不兼容的 provider，熔断切换后仍然会失败，用户体验反而更差（连续失败 →
  所有 provider 都被熔断 → 完全不可用）。

  建议：在队列构建阶段强制校验协议一致性，不兼容的 provider 直接剔除并记录警告。

  6. Hedged Requests（5.7.4）不建议纳入

  对冲请求在 LLM API 场景下成本极高（token
  计费是双倍），且流式响应难以取消已产生的计费。放在文档里会给实现者造成"应该做"的暗示。建议删除或明确标注为"不推荐"。

  ---
Tools
Manage the tools an LLM can use.

Tools allow the LLM to perform actions in your codebase. OpenCode comes with a set of built-in tools, but you can extend it with custom tools or MCP servers.

By default, all tools are enabled and don’t need permission to run. You can control tool behavior through permissions.

Configure
Use the permission field to control tool behavior. You can allow, deny, or require approval for each tool.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "edit": "deny",
    "bash": "ask",
    "webfetch": "allow"
  }
}

You can also use wildcards to control multiple tools at once. For example, to require approval for all tools from an MCP server:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "mymcp_*": "ask"
  }
}

Learn more about configuring permissions.

Built-in
Here are all the built-in tools available in OpenCode.

bash
Execute shell commands in your project environment.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "bash": "allow"
  }
}

This tool allows the LLM to run terminal commands like npm install, git status, or any other shell command.

edit
Modify existing files using exact string replacements.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "edit": "allow"
  }
}

This tool performs precise edits to files by replacing exact text matches. It’s the primary way the LLM modifies code.

write
Create new files or overwrite existing ones.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "edit": "allow"
  }
}

Use this to allow the LLM to create new files. It will overwrite existing files if they already exist.

Note

The write tool is controlled by the edit permission, which covers all file modifications (edit, write, patch, multiedit).

read
Read file contents from your codebase.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "read": "allow"
  }
}

This tool reads files and returns their contents. It supports reading specific line ranges for large files.

grep
Search file contents using regular expressions.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "grep": "allow"
  }
}

Fast content search across your codebase. Supports full regex syntax and file pattern filtering.

glob
Find files by pattern matching.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "glob": "allow"
  }
}

Search for files using glob patterns like **/*.js or src/**/*.ts. Returns matching file paths sorted by modification time.

list
List files and directories in a given path.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "list": "allow"
  }
}

This tool lists directory contents. It accepts glob patterns to filter results.

lsp (experimental)
Interact with your configured LSP servers to get code intelligence features like definitions, references, hover info, and call hierarchy.

Note

This tool is only available when OPENCODE_EXPERIMENTAL_LSP_TOOL=true (or OPENCODE_EXPERIMENTAL=true).

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "lsp": "allow"
  }
}

Supported operations include goToDefinition, findReferences, hover, documentSymbol, workspaceSymbol, goToImplementation, prepareCallHierarchy, incomingCalls, and outgoingCalls.

To configure which LSP servers are available for your project, see LSP Servers.

patch
Apply patches to files.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "edit": "allow"
  }
}

This tool applies patch files to your codebase. Useful for applying diffs and patches from various sources.

Note

The patch tool is controlled by the edit permission, which covers all file modifications (edit, write, patch, multiedit).

skill
Load a skill (a SKILL.md file) and return its content in the conversation.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "skill": "allow"
  }
}

todowrite
Manage todo lists during coding sessions.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "todowrite": "allow"
  }
}

Creates and updates task lists to track progress during complex operations. The LLM uses this to organize multi-step tasks.

Note

This tool is disabled for subagents by default, but you can enable it manually. Learn more

todoread
Read existing todo lists.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "todoread": "allow"
  }
}

Reads the current todo list state. Used by the LLM to track what tasks are pending or completed.

Note

This tool is disabled for subagents by default, but you can enable it manually. Learn more

webfetch
Fetch web content.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "webfetch": "allow"
  }
}

Allows the LLM to fetch and read web pages. Useful for looking up documentation or researching online resources.

question
Ask the user questions during execution.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "question": "allow"
  }
}

This tool allows the LLM to ask the user questions during a task. It’s useful for:

Gathering user preferences or requirements
Clarifying ambiguous instructions
Getting decisions on implementation choices
Offering choices about what direction to take
Each question includes a header, the question text, and a list of options. Users can select from the provided options or type a custom answer. When there are multiple questions, users can navigate between them before submitting all answers.

Custom tools
Custom tools let you define your own functions that the LLM can call. These are defined in your config file and can execute arbitrary code.

Learn more about creating custom tools.

MCP servers
MCP (Model Context Protocol) servers allow you to integrate external tools and services. This includes database access, API integrations, and third-party services.

Learn more about configuring MCP servers.

Internals
Internally, tools like grep, glob, and list use ripgrep under the hood. By default, ripgrep respects .gitignore patterns, which means files and directories listed in your .gitignore will be excluded from searches and listings.

Ignore patterns
To include files that would normally be ignored, create a .ignore file in your project root. This file can explicitly allow certain paths.

.ignore
!node_modules/
!dist/
!build/

For example, this .ignore file allows ripgrep to search within node_modules/, dist/, and build/ directories even if they’re listed in .gitignore.   



Rules
Set custom instructions for opencode.

You can provide custom instructions to opencode by creating an AGENTS.md file. This is similar to Cursor’s rules. It contains instructions that will be included in the LLM’s context to customize its behavior for your specific project.

Initialize
To create a new AGENTS.md file, you can run the /init command in opencode.

Tip

You should commit your project’s AGENTS.md file to Git.

This will scan your project and all its contents to understand what the project is about and generate an AGENTS.md file with it. This helps opencode to navigate the project better.

If you have an existing AGENTS.md file, this will try to add to it.

Example
You can also just create this file manually. Here’s an example of some things you can put into an AGENTS.md file.

AGENTS.md
# SST v3 Monorepo Project

This is an SST v3 monorepo with TypeScript. The project uses bun workspaces for package management.

## Project Structure

- `packages/` - Contains all workspace packages (functions, core, web, etc.)
- `infra/` - Infrastructure definitions split by service (storage.ts, api.ts, web.ts)
- `sst.config.ts` - Main SST configuration with dynamic imports

## Code Standards

- Use TypeScript with strict mode enabled
- Shared code goes in `packages/core/` with proper exports configuration
- Functions go in `packages/functions/`
- Infrastructure should be split into logical files in `infra/`

## Monorepo Conventions

- Import shared modules using workspace names: `@my-app/core/example`

We are adding project-specific instructions here and this will be shared across your team.

Types
opencode also supports reading the AGENTS.md file from multiple locations. And this serves different purposes.

Project
Place an AGENTS.md in your project root for project-specific rules. These only apply when you are working in this directory or its sub-directories.

Global
You can also have global rules in a ~/.config/opencode/AGENTS.md file. This gets applied across all opencode sessions.

Since this isn’t committed to Git or shared with your team, we recommend using this to specify any personal rules that the LLM should follow.

Claude Code Compatibility
For users migrating from Claude Code, OpenCode supports Claude Code’s file conventions as fallbacks:

Project rules: CLAUDE.md in your project directory (used if no AGENTS.md exists)
Global rules: ~/.claude/CLAUDE.md (used if no ~/.config/opencode/AGENTS.md exists)
Skills: ~/.claude/skills/ — see Agent Skills for details
To disable Claude Code compatibility, set one of these environment variables:

Terminal window
export OPENCODE_DISABLE_CLAUDE_CODE=1        # Disable all .claude support
export OPENCODE_DISABLE_CLAUDE_CODE_PROMPT=1 # Disable only ~/.claude/CLAUDE.md
export OPENCODE_DISABLE_CLAUDE_CODE_SKILLS=1 # Disable only .claude/skills

Precedence
When opencode starts, it looks for rule files in this order:

Local files by traversing up from the current directory (AGENTS.md, CLAUDE.md, or CONTEXT.md)
Global file at ~/.config/opencode/AGENTS.md
Claude Code file at ~/.claude/CLAUDE.md (unless disabled)
The first matching file wins in each category. For example, if you have both AGENTS.md and CLAUDE.md, only AGENTS.md is used. Similarly, ~/.config/opencode/AGENTS.md takes precedence over ~/.claude/CLAUDE.md.

Custom Instructions
You can specify custom instruction files in your opencode.json or the global ~/.config/opencode/opencode.json. This allows you and your team to reuse existing rules rather than having to duplicate them to AGENTS.md.

Example:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "instructions": ["CONTRIBUTING.md", "docs/guidelines.md", ".cursor/rules/*.md"]
}

You can also use remote URLs to load instructions from the web.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "instructions": ["https://raw.githubusercontent.com/my-org/shared-rules/main/style.md"]
}

Remote instructions are fetched with a 5 second timeout.

All instruction files are combined with your AGENTS.md files.

Referencing External Files
While opencode doesn’t automatically parse file references in AGENTS.md, you can achieve similar functionality in two ways:

Using opencode.json
The recommended approach is to use the instructions field in opencode.json:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "instructions": ["docs/development-standards.md", "test/testing-guidelines.md", "packages/*/AGENTS.md"]
}

Manual Instructions in AGENTS.md
You can teach opencode to read external files by providing explicit instructions in your AGENTS.md. Here’s a practical example:

AGENTS.md
# TypeScript Project Rules

## External File Loading

CRITICAL: When you encounter a file reference (e.g., @rules/general.md), use your Read tool to load it on a need-to-know basis. They're relevant to the SPECIFIC task at hand.

Instructions:

- Do NOT preemptively load all references - use lazy loading based on actual need
- When loaded, treat content as mandatory instructions that override defaults
- Follow references recursively when needed

## Development Guidelines

For TypeScript code style and best practices: @docs/typescript-guidelines.md
For React component architecture and hooks patterns: @docs/react-patterns.md
For REST API design and error handling: @docs/api-standards.md
For testing strategies and coverage requirements: @test/testing-guidelines.md

## General Guidelines

Read the following file immediately as it's relevant to all workflows: @rules/general-guidelines.md.

This approach allows you to:

Create modular, reusable rule files
Share rules across projects via symlinks or git submodules
Keep AGENTS.md concise while referencing detailed guidelines
Ensure opencode loads files only when needed for the specific task
Tip

For monorepos or projects with shared standards, using opencode.json with glob patterns (like packages/*/AGENTS.md) is more maintainable than manual instructions.

Edit this page
Find a bug? Open an issue
Join our Discord community





Agents
Configure and use specialized agents.

Agents are specialized AI assistants that can be configured for specific tasks and workflows. They allow you to create focused tools with custom prompts, models, and tool access.

Tip

Use the plan agent to analyze code and review suggestions without making any code changes.

You can switch between agents during a session or invoke them with the @ mention.

Types
There are two types of agents in OpenCode; primary agents and subagents.

Primary agents
Primary agents are the main assistants you interact with directly. You can cycle through them using the Tab key, or your configured switch_agent keybind. These agents handle your main conversation. Tool access is configured via permissions — for example, Build has all tools enabled while Plan is restricted.

Tip

You can use the Tab key to switch between primary agents during a session.

OpenCode comes with two built-in primary agents, Build and Plan. We’ll look at these below.

Subagents
Subagents are specialized assistants that primary agents can invoke for specific tasks. You can also manually invoke them by @ mentioning them in your messages.

OpenCode comes with two built-in subagents, General and Explore. We’ll look at this below.

Built-in
OpenCode comes with two built-in primary agents and two built-in subagents.

Build
Mode: primary

Build is the default primary agent with all tools enabled. This is the standard agent for development work where you need full access to file operations and system commands.

Plan
Mode: primary

A restricted agent designed for planning and analysis. We use a permission system to give you more control and prevent unintended changes. By default, all of the following are set to ask:

file edits: All writes, patches, and edits
bash: All bash commands
This agent is useful when you want the LLM to analyze code, suggest changes, or create plans without making any actual modifications to your codebase.

General
Mode: subagent

A general-purpose agent for researching complex questions and executing multi-step tasks. Has full tool access (except todo), so it can make file changes when needed. Use this to run multiple units of work in parallel.

Explore
Mode: subagent

A fast, read-only agent for exploring codebases. Cannot modify files. Use this when you need to quickly find files by patterns, search code for keywords, or answer questions about the codebase.

Usage
For primary agents, use the Tab key to cycle through them during a session. You can also use your configured switch_agent keybind.

Subagents can be invoked:

Automatically by primary agents for specialized tasks based on their descriptions.

Manually by @ mentioning a subagent in your message. For example.

@general help me search for this function

Navigation between sessions: When subagents create their own child sessions, you can navigate between the parent session and all child sessions using:

<Leader>+Right (or your configured session_child_cycle keybind) to cycle forward through parent → child1 → child2 → … → parent
<Leader>+Left (or your configured session_child_cycle_reverse keybind) to cycle backward through parent ← child1 ← child2 ← … ← parent
This allows you to seamlessly switch between the main conversation and specialized subagent work.

Configure
You can customize the built-in agents or create your own through configuration. Agents can be configured in two ways:

JSON
Configure agents in your opencode.json config file:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "agent": {
    "build": {
      "mode": "primary",
      "model": "anthropic/claude-sonnet-4-20250514",
      "prompt": "{file:./prompts/build.txt}",
      "tools": {
        "write": true,
        "edit": true,
        "bash": true
      }
    },
    "plan": {
      "mode": "primary",
      "model": "anthropic/claude-haiku-4-20250514",
      "tools": {
        "write": false,
        "edit": false,
        "bash": false
      }
    },
    "code-reviewer": {
      "description": "Reviews code for best practices and potential issues",
      "mode": "subagent",
      "model": "anthropic/claude-sonnet-4-20250514",
      "prompt": "You are a code reviewer. Focus on security, performance, and maintainability.",
      "tools": {
        "write": false,
        "edit": false
      }
    }
  }
}

Markdown
You can also define agents using markdown files. Place them in:

Global: ~/.config/opencode/agents/
Per-project: .opencode/agents/
~/.config/opencode/agents/review.md
---
description: Reviews code for quality and best practices
mode: subagent
model: anthropic/claude-sonnet-4-20250514
temperature: 0.1
tools:
  write: false
  edit: false
  bash: false
---

You are in code review mode. Focus on:

- Code quality and best practices
- Potential bugs and edge cases
- Performance implications
- Security considerations

Provide constructive feedback without making direct changes.

The markdown file name becomes the agent name. For example, review.md creates a review agent.

Options
Let’s look at these configuration options in detail.

Description
Use the description option to provide a brief description of what the agent does and when to use it.

opencode.json
{
  "agent": {
    "review": {
      "description": "Reviews code for best practices and potential issues"
    }
  }
}

This is a required config option.

Temperature
Control the randomness and creativity of the LLM’s responses with the temperature config.

Lower values make responses more focused and deterministic, while higher values increase creativity and variability.

opencode.json
{
  "agent": {
    "plan": {
      "temperature": 0.1
    },
    "creative": {
      "temperature": 0.8
    }
  }
}

Temperature values typically range from 0.0 to 1.0:

0.0-0.2: Very focused and deterministic responses, ideal for code analysis and planning
0.3-0.5: Balanced responses with some creativity, good for general development tasks
0.6-1.0: More creative and varied responses, useful for brainstorming and exploration
opencode.json
{
  "agent": {
    "analyze": {
      "temperature": 0.1,
      "prompt": "{file:./prompts/analysis.txt}"
    },
    "build": {
      "temperature": 0.3
    },
    "brainstorm": {
      "temperature": 0.7,
      "prompt": "{file:./prompts/creative.txt}"
    }
  }
}

If no temperature is specified, OpenCode uses model-specific defaults; typically 0 for most models, 0.55 for Qwen models.

Max steps
Control the maximum number of agentic iterations an agent can perform before being forced to respond with text only. This allows users who wish to control costs to set a limit on agentic actions.

If this is not set, the agent will continue to iterate until the model chooses to stop or the user interrupts the session.

opencode.json
{
  "agent": {
    "quick-thinker": {
      "description": "Fast reasoning with limited iterations",
      "prompt": "You are a quick thinker. Solve problems with minimal steps.",
      "maxSteps": 5
    }
  }
}

When the limit is reached, the agent receives a special system prompt instructing it to respond with a summarization of its work and recommended remaining tasks.

Disable
Set to true to disable the agent.

opencode.json
{
  "agent": {
    "review": {
      "disable": true
    }
  }
}

Prompt
Specify a custom system prompt file for this agent with the prompt config. The prompt file should contain instructions specific to the agent’s purpose.

opencode.json
{
  "agent": {
    "review": {
      "prompt": "{file:./prompts/code-review.txt}"
    }
  }
}

This path is relative to where the config file is located. So this works for both the global OpenCode config and the project specific config.

Model
Use the model config to override the model for this agent. Useful for using different models optimized for different tasks. For example, a faster model for planning, a more capable model for implementation.

Tip

If you don’t specify a model, primary agents use the model globally configured while subagents will use the model of the primary agent that invoked the subagent.

opencode.json
{
  "agent": {
    "plan": {
      "model": "anthropic/claude-haiku-4-20250514"
    }
  }
}

The model ID in your OpenCode config uses the format provider/model-id. For example, if you’re using OpenCode Zen, you would use opencode/gpt-5.1-codex for GPT 5.1 Codex.

Tools
Control which tools are available in this agent with the tools config. You can enable or disable specific tools by setting them to true or false.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "tools": {
    "write": true,
    "bash": true
  },
  "agent": {
    "plan": {
      "tools": {
        "write": false,
        "bash": false
      }
    }
  }
}

Note

The agent-specific config overrides the global config.

You can also use wildcards to control multiple tools at once. For example, to disable all tools from an MCP server:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "agent": {
    "readonly": {
      "tools": {
        "mymcp_*": false,
        "write": false,
        "edit": false
      }
    }
  }
}

Learn more about tools.

Permissions
You can configure permissions to manage what actions an agent can take. Currently, the permissions for the edit, bash, and webfetch tools can be configured to:

"ask" — Prompt for approval before running the tool
"allow" — Allow all operations without approval
"deny" — Disable the tool
opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "edit": "deny"
  }
}

You can override these permissions per agent.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "edit": "deny"
  },
  "agent": {
    "build": {
      "permission": {
        "edit": "ask"
      }
    }
  }
}

You can also set permissions in Markdown agents.

~/.config/opencode/agents/review.md
---
description: Code review without edits
mode: subagent
permission:
  edit: deny
  bash:
    "*": ask
    "git diff": allow
    "git log*": allow
    "grep *": allow
  webfetch: deny
---

Only analyze code and suggest changes.

You can set permissions for specific bash commands.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "agent": {
    "build": {
      "permission": {
        "bash": {
          "git push": "ask",
          "grep *": "allow"
        }
      }
    }
  }
}

This can take a glob pattern.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "agent": {
    "build": {
      "permission": {
        "bash": {
          "git *": "ask"
        }
      }
    }
  }
}

And you can also use the * wildcard to manage permissions for all commands. Since the last matching rule takes precedence, put the * wildcard first and specific rules after.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "agent": {
    "build": {
      "permission": {
        "bash": {
          "*": "ask",
          "git status *": "allow"
        }
      }
    }
  }
}

Learn more about permissions.

Mode
Control the agent’s mode with the mode config. The mode option is used to determine how the agent can be used.

opencode.json
{
  "agent": {
    "review": {
      "mode": "subagent"
    }
  }
}

The mode option can be set to primary, subagent, or all. If no mode is specified, it defaults to all.

Hidden
Hide a subagent from the @ autocomplete menu with hidden: true. Useful for internal subagents that should only be invoked programmatically by other agents via the Task tool.

opencode.json
{
  "agent": {
    "internal-helper": {
      "mode": "subagent",
      "hidden": true
    }
  }
}

This only affects user visibility in the autocomplete menu. Hidden agents can still be invoked by the model via the Task tool if permissions allow.

Note

Only applies to mode: subagent agents.

Task permissions
Control which subagents an agent can invoke via the Task tool with permission.task. Uses glob patterns for flexible matching.

opencode.json
{
  "agent": {
    "orchestrator": {
      "mode": "primary",
      "permission": {
        "task": {
          "*": "deny",
          "orchestrator-*": "allow",
          "code-reviewer": "ask"
        }
      }
    }
  }
}

When set to deny, the subagent is removed from the Task tool description entirely, so the model won’t attempt to invoke it.

Tip

Rules are evaluated in order, and the last matching rule wins. In the example above, orchestrator-planner matches both * (deny) and orchestrator-* (allow), but since orchestrator-* comes after *, the result is allow.

Tip

Users can always invoke any subagent directly via the @ autocomplete menu, even if the agent’s task permissions would deny it.

Additional
Any other options you specify in your agent configuration will be passed through directly to the provider as model options. This allows you to use provider-specific features and parameters.

For example, with OpenAI’s reasoning models, you can control the reasoning effort:

opencode.json
{
  "agent": {
    "deep-thinker": {
      "description": "Agent that uses high reasoning effort for complex problems",
      "model": "openai/gpt-5",
      "reasoningEffort": "high",
      "textVerbosity": "low"
    }
  }
}

These additional options are model and provider-specific. Check your provider’s documentation for available parameters.

Tip

Run opencode models to see a list of the available models.

Create agents
You can create new agents using the following command:

Terminal window
opencode agent create

This interactive command will:

Ask where to save the agent; global or project-specific.
Description of what the agent should do.
Generate an appropriate system prompt and identifier.
Let you select which tools the agent can access.
Finally, create a markdown file with the agent configuration.
Use cases
Here are some common use cases for different agents.

Build agent: Full development work with all tools enabled
Plan agent: Analysis and planning without making changes
Review agent: Code review with read-only access plus documentation tools
Debug agent: Focused on investigation with bash and read tools enabled
Docs agent: Documentation writing with file operations but no system commands
Examples
Here are some example agents you might find useful.

Tip

Do you have an agent you’d like to share? Submit a PR.

Documentation agent
~/.config/opencode/agents/docs-writer.md
---
description: Writes and maintains project documentation
mode: subagent
tools:
  bash: false
---

You are a technical writer. Create clear, comprehensive documentation.

Focus on:

- Clear explanations
- Proper structure
- Code examples
- User-friendly language

Security auditor
~/.config/opencode/agents/security-auditor.md
---
description: Performs security audits and identifies vulnerabilities
mode: subagent
tools:
  write: false
  edit: false
---

You are a security expert. Focus on identifying potential security issues.

Look for:

- Input validation vulnerabilities
- Authentication and authorization flaws
- Data exposure risks
- Dependency vulnerabilities
- Configuration security issues






Models
Configuring an LLM provider and model.

OpenCode uses the AI SDK and Models.dev to support 75+ LLM providers and it supports running local models.

Providers
Most popular providers are preloaded by default. If you’ve added the credentials for a provider through the /connect command, they’ll be available when you start OpenCode.

Learn more about providers.

Select a model
Once you’ve configured your provider you can select the model you want by typing in:

/models

Recommended models
There are a lot of models out there, with new models coming out every week.

Tip

Consider using one of the models we recommend.

However, there are only a few of them that are good at both generating code and tool calling.

Here are several models that work well with OpenCode, in no particular order. (This is not an exhaustive list nor is it necessarily up to date):

GPT 5.2
GPT 5.1 Codex
Claude Opus 4.5
Claude Sonnet 4.5
Minimax M2.1
Gemini 3 Pro
Set a default
To set one of these as the default model, you can set the model key in your OpenCode config.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "model": "lmstudio/google/gemma-3n-e4b"
}

Here the full ID is provider_id/model_id. For example, if you’re using OpenCode Zen, you would use opencode/gpt-5.1-codex for GPT 5.1 Codex.

If you’ve configured a custom provider, the provider_id is key from the provider part of your config, and the model_id is the key from provider.models.

Configure models
You can globally configure a model’s options through the config.

opencode.jsonc
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "openai": {
      "models": {
        "gpt-5": {
          "options": {
            "reasoningEffort": "high",
            "textVerbosity": "low",
            "reasoningSummary": "auto",
            "include": ["reasoning.encrypted_content"],
          },
        },
      },
    },
    "anthropic": {
      "models": {
        "claude-sonnet-4-5-20250929": {
          "options": {
            "thinking": {
              "type": "enabled",
              "budgetTokens": 16000,
            },
          },
        },
      },
    },
  },
}

Here we’re configuring global settings for two built-in models: gpt-5 when accessed via the openai provider, and claude-sonnet-4-20250514 when accessed via the anthropic provider. The built-in provider and model names can be found on Models.dev.

You can also configure these options for any agents that you are using. The agent config overrides any global options here. Learn more.

You can also define custom variants that extend built-in ones. Variants let you configure different settings for the same model without creating duplicate entries:

opencode.jsonc
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "opencode": {
      "models": {
        "gpt-5": {
          "variants": {
            "high": {
              "reasoningEffort": "high",
              "textVerbosity": "low",
              "reasoningSummary": "auto",
            },
            "low": {
              "reasoningEffort": "low",
              "textVerbosity": "low",
              "reasoningSummary": "auto",
            },
          },
        },
      },
    },
  },
}

Variants
Many models support multiple variants with different configurations. OpenCode ships with built-in default variants for popular providers.

Built-in variants
OpenCode ships with default variants for many providers:

Anthropic:

high - High thinking budget (default)
max - Maximum thinking budget
OpenAI:

Varies by model but roughly:

none - No reasoning
minimal - Minimal reasoning effort
low - Low reasoning effort
medium - Medium reasoning effort
high - High reasoning effort
xhigh - Extra high reasoning effort
Google:

low - Lower effort/token budget
high - Higher effort/token budget
Tip

This list is not comprehensive. Many other providers have built-in defaults too.

Custom variants
You can override existing variants or add your own:

opencode.jsonc
{
  "$schema": "https://opencode.ai/config.json",
  "provider": {
    "openai": {
      "models": {
        "gpt-5": {
          "variants": {
            "thinking": {
              "reasoningEffort": "high",
              "textVerbosity": "low",
            },
            "fast": {
              "disabled": true,
            },
          },
        },
      },
    },
  },
}

Cycle variants
Use the keybind variant_cycle to quickly switch between variants. Learn more.

Loading models
When OpenCode starts up, it checks for models in the following priority order:

The --model or -m command line flag. The format is the same as in the config file: provider_id/model_id.

The model list in the OpenCode config.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "model": "anthropic/claude-sonnet-4-20250514"
}

The format here is provider/model.

The last used model.

The first model using an internal priority.






Themes
Select a built-in theme or define your own.

With OpenCode you can select from one of several built-in themes, use a theme that adapts to your terminal theme, or define your own custom theme.

By default, OpenCode uses our own opencode theme.

Terminal requirements
For themes to display correctly with their full color palette, your terminal must support truecolor (24-bit color). Most modern terminals support this by default, but you may need to enable it:

Check support: Run echo $COLORTERM - it should output truecolor or 24bit
Enable truecolor: Set the environment variable COLORTERM=truecolor in your shell profile
Terminal compatibility: Ensure your terminal emulator supports 24-bit color (most modern terminals like iTerm2, Alacritty, Kitty, Windows Terminal, and recent versions of GNOME Terminal do)
Without truecolor support, themes may appear with reduced color accuracy or fall back to the nearest 256-color approximation.

Built-in themes
OpenCode comes with several built-in themes.

Name	Description
system	Adapts to your terminal’s background color
tokyonight	Based on the Tokyonight theme
everforest	Based on the Everforest theme
ayu	Based on the Ayu dark theme
catppuccin	Based on the Catppuccin theme
catppuccin-macchiato	Based on the Catppuccin theme
gruvbox	Based on the Gruvbox theme
kanagawa	Based on the Kanagawa theme
nord	Based on the Nord theme
matrix	Hacker-style green on black theme
one-dark	Based on the Atom One Dark theme
And more, we are constantly adding new themes.

System theme
The system theme is designed to automatically adapt to your terminal’s color scheme. Unlike traditional themes that use fixed colors, the system theme:

Generates gray scale: Creates a custom gray scale based on your terminal’s background color, ensuring optimal contrast.
Uses ANSI colors: Leverages standard ANSI colors (0-15) for syntax highlighting and UI elements, which respect your terminal’s color palette.
Preserves terminal defaults: Uses none for text and background colors to maintain your terminal’s native appearance.
The system theme is for users who:

Want OpenCode to match their terminal’s appearance
Use custom terminal color schemes
Prefer a consistent look across all terminal applications
Using a theme
You can select a theme by bringing up the theme select with the /theme command. Or you can specify it in your config.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "theme": "tokyonight"
}

Custom themes
OpenCode supports a flexible JSON-based theme system that allows users to create and customize themes easily.

Hierarchy
Themes are loaded from multiple directories in the following order where later directories override earlier ones:

Built-in themes - These are embedded in the binary
User config directory - Defined in ~/.config/opencode/themes/*.json or $XDG_CONFIG_HOME/opencode/themes/*.json
Project root directory - Defined in the <project-root>/.opencode/themes/*.json
Current working directory - Defined in ./.opencode/themes/*.json
If multiple directories contain a theme with the same name, the theme from the directory with higher priority will be used.

Creating a theme
To create a custom theme, create a JSON file in one of the theme directories.

For user-wide themes:

Terminal window
mkdir -p ~/.config/opencode/themes
vim ~/.config/opencode/themes/my-theme.json

And for project-specific themes.

Terminal window
mkdir -p .opencode/themes
vim .opencode/themes/my-theme.json

JSON format
Themes use a flexible JSON format with support for:

Hex colors: "#ffffff"
ANSI colors: 3 (0-255)
Color references: "primary" or custom definitions
Dark/light variants: {"dark": "#000", "light": "#fff"}
No color: "none" - Uses the terminal’s default color or transparent
Color definitions
The defs section is optional and it allows you to define reusable colors that can be referenced in the theme.

Terminal defaults
The special value "none" can be used for any color to inherit the terminal’s default color. This is particularly useful for creating themes that blend seamlessly with your terminal’s color scheme:

"text": "none" - Uses terminal’s default foreground color
"background": "none" - Uses terminal’s default background color
Example
Here’s an example of a custom theme:

my-theme.json
{
  "$schema": "https://opencode.ai/theme.json",
  "defs": {
    "nord0": "#2E3440",
    "nord1": "#3B4252",
    "nord2": "#434C5E",
    "nord3": "#4C566A",
    "nord4": "#D8DEE9",
    "nord5": "#E5E9F0",
    "nord6": "#ECEFF4",
    "nord7": "#8FBCBB",
    "nord8": "#88C0D0",
    "nord9": "#81A1C1",
    "nord10": "#5E81AC",
    "nord11": "#BF616A",
    "nord12": "#D08770",
    "nord13": "#EBCB8B",
    "nord14": "#A3BE8C",
    "nord15": "#B48EAD"
  },
  "theme": {
    "primary": {
      "dark": "nord8",
      "light": "nord10"
    },
    "secondary": {
      "dark": "nord9",
      "light": "nord9"
    },
    "accent": {
      "dark": "nord7",
      "light": "nord7"
    },
    "error": {
      "dark": "nord11",
      "light": "nord11"
    },
    "warning": {
      "dark": "nord12",
      "light": "nord12"
    },
    "success": {
      "dark": "nord14",
      "light": "nord14"
    },
    "info": {
      "dark": "nord8",
      "light": "nord10"
    },
    "text": {
      "dark": "nord4",
      "light": "nord0"
    },
    "textMuted": {
      "dark": "nord3",
      "light": "nord1"
    },
    "background": {
      "dark": "nord0",
      "light": "nord6"
    },
    "backgroundPanel": {
      "dark": "nord1",
      "light": "nord5"
    },
    "backgroundElement": {
      "dark": "nord1",
      "light": "nord4"
    },
    "border": {
      "dark": "nord2",
      "light": "nord3"
    },
    "borderActive": {
      "dark": "nord3",
      "light": "nord2"
    },
    "borderSubtle": {
      "dark": "nord2",
      "light": "nord3"
    },
    "diffAdded": {
      "dark": "nord14",
      "light": "nord14"
    },
    "diffRemoved": {
      "dark": "nord11",
      "light": "nord11"
    },
    "diffContext": {
      "dark": "nord3",
      "light": "nord3"
    },
    "diffHunkHeader": {
      "dark": "nord3",
      "light": "nord3"
    },
    "diffHighlightAdded": {
      "dark": "nord14",
      "light": "nord14"
    },
    "diffHighlightRemoved": {
      "dark": "nord11",
      "light": "nord11"
    },
    "diffAddedBg": {
      "dark": "#3B4252",
      "light": "#E5E9F0"
    },
    "diffRemovedBg": {
      "dark": "#3B4252",
      "light": "#E5E9F0"
    },
    "diffContextBg": {
      "dark": "nord1",
      "light": "nord5"
    },
    "diffLineNumber": {
      "dark": "nord2",
      "light": "nord4"
    },
    "diffAddedLineNumberBg": {
      "dark": "#3B4252",
      "light": "#E5E9F0"
    },
    "diffRemovedLineNumberBg": {
      "dark": "#3B4252",
      "light": "#E5E9F0"
    },
    "markdownText": {
      "dark": "nord4",
      "light": "nord0"
    },
    "markdownHeading": {
      "dark": "nord8",
      "light": "nord10"
    },
    "markdownLink": {
      "dark": "nord9",
      "light": "nord9"
    },
    "markdownLinkText": {
      "dark": "nord7",
      "light": "nord7"
    },
    "markdownCode": {
      "dark": "nord14",
      "light": "nord14"
    },
    "markdownBlockQuote": {
      "dark": "nord3",
      "light": "nord3"
    },
    "markdownEmph": {
      "dark": "nord12",
      "light": "nord12"
    },
    "markdownStrong": {
      "dark": "nord13",
      "light": "nord13"
    },
    "markdownHorizontalRule": {
      "dark": "nord3",
      "light": "nord3"
    },
    "markdownListItem": {
      "dark": "nord8",
      "light": "nord10"
    },
    "markdownListEnumeration": {
      "dark": "nord7",
      "light": "nord7"
    },
    "markdownImage": {
      "dark": "nord9",
      "light": "nord9"
    },
    "markdownImageText": {
      "dark": "nord7",
      "light": "nord7"
    },
    "markdownCodeBlock": {
      "dark": "nord4",
      "light": "nord0"
    },
    "syntaxComment": {
      "dark": "nord3",
      "light": "nord3"
    },
    "syntaxKeyword": {
      "dark": "nord9",
      "light": "nord9"
    },
    "syntaxFunction": {
      "dark": "nord8",
      "light": "nord8"
    },
    "syntaxVariable": {
      "dark": "nord7",
      "light": "nord7"
    },
    "syntaxString": {
      "dark": "nord14",
      "light": "nord14"
    },
    "syntaxNumber": {
      "dark": "nord15",
      "light": "nord15"
    },
    "syntaxType": {
      "dark": "nord7",
      "light": "nord7"
    },
    "syntaxOperator": {
      "dark": "nord9",
      "light": "nord9"
    },
    "syntaxPunctuation": {
      "dark": "nord4",
      "light": "nord0"
    }
  }
}




Keybinds
Customize your keybinds.

OpenCode has a list of keybinds that you can customize through the OpenCode config.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "keybinds": {
    "leader": "ctrl+x",
    "app_exit": "ctrl+c,ctrl+d,<leader>q",
    "editor_open": "<leader>e",
    "theme_list": "<leader>t",
    "sidebar_toggle": "<leader>b",
    "scrollbar_toggle": "none",
    "username_toggle": "none",
    "status_view": "<leader>s",
    "tool_details": "none",
    "session_export": "<leader>x",
    "session_new": "<leader>n",
    "session_list": "<leader>l",
    "session_timeline": "<leader>g",
    "session_fork": "none",
    "session_rename": "none",
    "session_share": "none",
    "session_unshare": "none",
    "session_interrupt": "escape",
    "session_compact": "<leader>c",
    "session_child_cycle": "<leader>right",
    "session_child_cycle_reverse": "<leader>left",
    "session_parent": "<leader>up",
    "messages_page_up": "pageup,ctrl+alt+b",
    "messages_page_down": "pagedown,ctrl+alt+f",
    "messages_line_up": "ctrl+alt+y",
    "messages_line_down": "ctrl+alt+e",
    "messages_half_page_up": "ctrl+alt+u",
    "messages_half_page_down": "ctrl+alt+d",
    "messages_first": "ctrl+g,home",
    "messages_last": "ctrl+alt+g,end",
    "messages_next": "none",
    "messages_previous": "none",
    "messages_copy": "<leader>y",
    "messages_undo": "<leader>u",
    "messages_redo": "<leader>r",
    "messages_last_user": "none",
    "messages_toggle_conceal": "<leader>h",
    "model_list": "<leader>m",
    "model_cycle_recent": "f2",
    "model_cycle_recent_reverse": "shift+f2",
    "model_cycle_favorite": "none",
    "model_cycle_favorite_reverse": "none",
    "variant_cycle": "ctrl+t",
    "command_list": "ctrl+p",
    "agent_list": "<leader>a",
    "agent_cycle": "tab",
    "agent_cycle_reverse": "shift+tab",
    "input_clear": "ctrl+c",
    "input_paste": "ctrl+v",
    "input_submit": "return",
    "input_newline": "shift+return,ctrl+return,alt+return,ctrl+j",
    "input_move_left": "left,ctrl+b",
    "input_move_right": "right,ctrl+f",
    "input_move_up": "up",
    "input_move_down": "down",
    "input_select_left": "shift+left",
    "input_select_right": "shift+right",
    "input_select_up": "shift+up",
    "input_select_down": "shift+down",
    "input_line_home": "ctrl+a",
    "input_line_end": "ctrl+e",
    "input_select_line_home": "ctrl+shift+a",
    "input_select_line_end": "ctrl+shift+e",
    "input_visual_line_home": "alt+a",
    "input_visual_line_end": "alt+e",
    "input_select_visual_line_home": "alt+shift+a",
    "input_select_visual_line_end": "alt+shift+e",
    "input_buffer_home": "home",
    "input_buffer_end": "end",
    "input_select_buffer_home": "shift+home",
    "input_select_buffer_end": "shift+end",
    "input_delete_line": "ctrl+shift+d",
    "input_delete_to_line_end": "ctrl+k",
    "input_delete_to_line_start": "ctrl+u",
    "input_backspace": "backspace,shift+backspace",
    "input_delete": "ctrl+d,delete,shift+delete",
    "input_undo": "ctrl+-,super+z",
    "input_redo": "ctrl+.,super+shift+z",
    "input_word_forward": "alt+f,alt+right,ctrl+right",
    "input_word_backward": "alt+b,alt+left,ctrl+left",
    "input_select_word_forward": "alt+shift+f,alt+shift+right",
    "input_select_word_backward": "alt+shift+b,alt+shift+left",
    "input_delete_word_forward": "alt+d,alt+delete,ctrl+delete",
    "input_delete_word_backward": "ctrl+w,ctrl+backspace,alt+backspace",
    "history_previous": "up",
    "history_next": "down",
    "terminal_suspend": "ctrl+z",
    "terminal_title_toggle": "none",
    "tips_toggle": "<leader>h"
  }
}

Leader key
OpenCode uses a leader key for most keybinds. This avoids conflicts in your terminal.

By default, ctrl+x is the leader key and most actions require you to first press the leader key and then the shortcut. For example, to start a new session you first press ctrl+x and then press n.

You don’t need to use a leader key for your keybinds but we recommend doing so.

Disable keybind
You can disable a keybind by adding the key to your config with a value of “none”.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "keybinds": {
    "session_compact": "none"
  }
}

Desktop prompt shortcuts
The OpenCode desktop app prompt input supports common Readline/Emacs-style shortcuts for editing text. These are built-in and currently not configurable via opencode.json.

Shortcut	Action
ctrl+a	Move to start of current line
ctrl+e	Move to end of current line
ctrl+b	Move cursor back one character
ctrl+f	Move cursor forward one character
alt+b	Move cursor back one word
alt+f	Move cursor forward one word
ctrl+d	Delete character under cursor
ctrl+k	Kill to end of line
ctrl+u	Kill to start of line
ctrl+w	Kill previous word
alt+d	Kill next word
ctrl+t	Transpose characters
ctrl+g	Cancel popovers / abort running response
Shift+Enter
Some terminals don’t send modifier keys with Enter by default. You may need to configure your terminal to send Shift+Enter as an escape sequence.

Windows Terminal
Open your settings.json at:

%LOCALAPPDATA%\Packages\Microsoft.WindowsTerminal_8wekyb3d8bbwe\LocalState\settings.json

Add this to the root-level actions array:

"actions": [
  {
    "command": {
      "action": "sendInput",
      "input": "\u001b[13;2u"
    },
    "id": "User.sendInput.ShiftEnterCustom"
  }
]

Add this to the root-level keybindings array:

"keybindings": [
  {
    "keys": "shift+enter",
    "id": "User.sendInput.ShiftEnterCustom"
  }
]

Save the file and restart Windows Terminal or open a new tab.




Commands
Create custom commands for repetitive tasks.

Custom commands let you specify a prompt you want to run when that command is executed in the TUI.

/my-command

Custom commands are in addition to the built-in commands like /init, /undo, /redo, /share, /help. Learn more.

Create command files
Create markdown files in the commands/ directory to define custom commands.

Create .opencode/commands/test.md:

.opencode/commands/test.md
---
description: Run tests with coverage
agent: build
model: anthropic/claude-3-5-sonnet-20241022
---

Run the full test suite with coverage report and show any failures.
Focus on the failing tests and suggest fixes.

The frontmatter defines command properties. The content becomes the template.

Use the command by typing / followed by the command name.

"/test"

Configure
You can add custom commands through the OpenCode config or by creating markdown files in the commands/ directory.

JSON
Use the command option in your OpenCode config:

opencode.jsonc
{
  "$schema": "https://opencode.ai/config.json",
  "command": {
    // This becomes the name of the command
    "test": {
      // This is the prompt that will be sent to the LLM
      "template": "Run the full test suite with coverage report and show any failures.\nFocus on the failing tests and suggest fixes.",
      // This is shown as the description in the TUI
      "description": "Run tests with coverage",
      "agent": "build",
      "model": "anthropic/claude-3-5-sonnet-20241022"
    }
  }
}

Now you can run this command in the TUI:

/test

Markdown
You can also define commands using markdown files. Place them in:

Global: ~/.config/opencode/commands/
Per-project: .opencode/commands/
~/.config/opencode/commands/test.md
---
description: Run tests with coverage
agent: build
model: anthropic/claude-3-5-sonnet-20241022
---

Run the full test suite with coverage report and show any failures.
Focus on the failing tests and suggest fixes.

The markdown file name becomes the command name. For example, test.md lets you run:

/test

Prompt config
The prompts for the custom commands support several special placeholders and syntax.

Arguments
Pass arguments to commands using the $ARGUMENTS placeholder.

.opencode/commands/component.md
---
description: Create a new component
---

Create a new React component named $ARGUMENTS with TypeScript support.
Include proper typing and basic structure.

Run the command with arguments:

/component Button

And $ARGUMENTS will be replaced with Button.

You can also access individual arguments using positional parameters:

$1 - First argument
$2 - Second argument
$3 - Third argument
And so on…
For example:

.opencode/commands/create-file.md
---
description: Create a new file with content
---

Create a file named $1 in the directory $2
with the following content: $3

Run the command:

/create-file config.json src "{ \"key\": \"value\" }"

This replaces:

$1 with config.json
$2 with src
$3 with { "key": "value" }
Shell output
Use !command to inject bash command output into your prompt.

For example, to create a custom command that analyzes test coverage:

.opencode/commands/analyze-coverage.md
---
description: Analyze test coverage
---

Here are the current test results:
!`npm test`

Based on these results, suggest improvements to increase coverage.

Or to review recent changes:

.opencode/commands/review-changes.md
---
description: Review recent changes
---

Recent git commits:
!`git log --oneline -10`

Review these changes and suggest any improvements.

Commands run in your project’s root directory and their output becomes part of the prompt.

File references
Include files in your command using @ followed by the filename.

.opencode/commands/review-component.md
---
description: Review component
---

Review the component in @src/components/Button.tsx.
Check for performance issues and suggest improvements.

The file content gets included in the prompt automatically.

Options
Let’s look at the configuration options in detail.

Template
The template option defines the prompt that will be sent to the LLM when the command is executed.

opencode.json
{
  "command": {
    "test": {
      "template": "Run the full test suite with coverage report and show any failures.\nFocus on the failing tests and suggest fixes."
    }
  }
}

This is a required config option.

Description
Use the description option to provide a brief description of what the command does.

opencode.json
{
  "command": {
    "test": {
      "description": "Run tests with coverage"
    }
  }
}

This is shown as the description in the TUI when you type in the command.

Agent
Use the agent config to optionally specify which agent should execute this command. If this is a subagent the command will trigger a subagent invocation by default. To disable this behavior, set subtask to false.

opencode.json
{
  "command": {
    "review": {
      "agent": "plan"
    }
  }
}

This is an optional config option. If not specified, defaults to your current agent.

Subtask
Use the subtask boolean to force the command to trigger a subagent invocation. This is useful if you want the command to not pollute your primary context and will force the agent to act as a subagent, even if mode is set to primary on the agent configuration.

opencode.json
{
  "command": {
    "analyze": {
      "subtask": true
    }
  }
}

This is an optional config option.

Model
Use the model config to override the default model for this command.

opencode.json
{
  "command": {
    "analyze": {
      "model": "anthropic/claude-3-5-sonnet-20241022"
    }
  }
}

This is an optional config option.

Built-in
opencode includes several built-in commands like /init, /undo, /redo, /share, /help; learn more.

Note

Custom commands can override built-in commands.

If you define a custom command with the same name, it will override the built-in command.





Formatters
OpenCode uses language specific formatters.

OpenCode automatically formats files after they are written or edited using language-specific formatters. This ensures that the code that is generated follows the code styles of your project.

Built-in
OpenCode comes with several built-in formatters for popular languages and frameworks. Below is a list of the formatters, supported file extensions, and commands or config options it needs.

Formatter	Extensions	Requirements
gofmt	.go	gofmt command available
mix	.ex, .exs, .eex, .heex, .leex, .neex, .sface	mix command available
prettier	.js, .jsx, .ts, .tsx, .html, .css, .md, .json, .yaml, and more	prettier dependency in package.json
biome	.js, .jsx, .ts, .tsx, .html, .css, .md, .json, .yaml, and more	biome.json(c) config file
zig	.zig, .zon	zig command available
clang-format	.c, .cpp, .h, .hpp, .ino, and more	.clang-format config file
ktlint	.kt, .kts	ktlint command available
ruff	.py, .pyi	ruff command available with config
rustfmt	.rs	rustfmt command available
cargofmt	.rs	cargo fmt command available
uv	.py, .pyi	uv command available
rubocop	.rb, .rake, .gemspec, .ru	rubocop command available
standardrb	.rb, .rake, .gemspec, .ru	standardrb command available
htmlbeautifier	.erb, .html.erb	htmlbeautifier command available
air	.R	air command available
dart	.dart	dart command available
ocamlformat	.ml, .mli	ocamlformat command available and .ocamlformat config file
terraform	.tf, .tfvars	terraform command available
gleam	.gleam	gleam command available
nixfmt	.nix	nixfmt command available
shfmt	.sh, .bash	shfmt command available
pint	.php	laravel/pint dependency in composer.json
oxfmt (Experimental)	.js, .jsx, .ts, .tsx	oxfmt dependency in package.json and an experimental env variable flag
So if your project has prettier in your package.json, OpenCode will automatically use it.

How it works
When OpenCode writes or edits a file, it:

Checks the file extension against all enabled formatters.
Runs the appropriate formatter command on the file.
Applies the formatting changes automatically.
This process happens in the background, ensuring your code styles are maintained without any manual steps.

Configure
You can customize formatters through the formatter section in your OpenCode config.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "formatter": {}
}

Each formatter configuration supports the following:

Property	Type	Description
disabled	boolean	Set this to true to disable the formatter
command	string[]	The command to run for formatting
environment	object	Environment variables to set when running the formatter
extensions	string[]	File extensions this formatter should handle
Let’s look at some examples.

Disabling formatters
To disable all formatters globally, set formatter to false:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "formatter": false
}

To disable a specific formatter, set disabled to true:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "formatter": {
    "prettier": {
      "disabled": true
    }
  }
}

Custom formatters
You can override the built-in formatters or add new ones by specifying the command, environment variables, and file extensions:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "formatter": {
    "prettier": {
      "command": ["npx", "prettier", "--write", "$FILE"],
      "environment": {
        "NODE_ENV": "development"
      },
      "extensions": [".js", ".ts", ".jsx", ".tsx"]
    },
    "custom-markdown-formatter": {
      "command": ["deno", "fmt", "$FILE"],
      "extensions": [".md"]
    }
  }
}

The $FILE placeholder in the command will be replaced with the path to the file being formatted.








Permissions
Control which actions require approval to run.

OpenCode uses the permission config to decide whether a given action should run automatically, prompt you, or be blocked.

As of v1.1.1, the legacy tools boolean config is deprecated and has been merged into permission. The old tools config is still supported for backwards compatibility.

Actions
Each permission rule resolves to one of:

"allow" — run without approval
"ask" — prompt for approval
"deny" — block the action
Configuration
You can set permissions globally (with *), and override specific tools.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "*": "ask",
    "bash": "allow",
    "edit": "deny"
  }
}

You can also set all permissions at once:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": "allow"
}

Granular Rules (Object Syntax)
For most permissions, you can use an object to apply different actions based on the tool input.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "bash": {
      "*": "ask",
      "git *": "allow",
      "npm *": "allow",
      "rm *": "deny",
      "grep *": "allow"
    },
    "edit": {
      "*": "deny",
      "packages/web/src/content/docs/*.mdx": "allow"
    }
  }
}

Rules are evaluated by pattern match, with the last matching rule winning. A common pattern is to put the catch-all "*" rule first, and more specific rules after it.

Wildcards
Permission patterns use simple wildcard matching:

* matches zero or more of any character
? matches exactly one character
All other characters match literally
Home Directory Expansion
You can use ~ or $HOME at the start of a pattern to reference your home directory. This is particularly useful for external_directory rules.

~/projects/* -> /Users/username/projects/*
$HOME/projects/* -> /Users/username/projects/*
~ -> /Users/username
Available Permissions
OpenCode permissions are keyed by tool name, plus a couple of safety guards:

read — reading a file (matches the file path)
edit — all file modifications (covers edit, write, patch, multiedit)
glob — file globbing (matches the glob pattern)
grep — content search (matches the regex pattern)
list — listing files in a directory (matches the directory path)
bash — running shell commands (matches parsed commands like git status --porcelain)
task — launching subagents (matches the subagent type)
skill — loading a skill (matches the skill name)
lsp — running LSP queries (currently non-granular)
todoread, todowrite — reading/updating the todo list
webfetch — fetching a URL (matches the URL)
websearch, codesearch — web/code search (matches the query)
external_directory — triggered when a tool touches paths outside the project working directory
doom_loop — triggered when the same tool call repeats 3 times with identical input
Defaults
If you don’t specify anything, OpenCode starts from permissive defaults:

Most permissions default to "allow".
doom_loop and external_directory default to "ask".
read is "allow", but .env files are denied by default:
opencode.json
{
  "permission": {
    "read": {
      "*": "allow",
      "*.env": "deny",
      "*.env.*": "deny",
      "*.env.example": "allow"
    }
  }
}

What “Ask” Does
When OpenCode prompts for approval, the UI offers three outcomes:

once — approve just this request
always — approve future requests matching the suggested patterns (for the rest of the current OpenCode session)
reject — deny the request
The set of patterns that always would approve is provided by the tool (for example, bash approvals typically whitelist a safe command prefix like git status*).

Agents
You can override permissions per agent. Agent permissions are merged with the global config, and agent rules take precedence. Learn more about agent permissions.

Note

Refer to the Granular Rules (Object Syntax) section above for more detailed pattern matching examples.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "permission": {
    "bash": {
      "*": "ask",
      "git *": "allow",
      "git commit *": "deny",
      "git push *": "deny",
      "grep *": "allow"
    }
  },
  "agent": {
    "build": {
      "permission": {
        "bash": {
          "*": "ask",
          "git *": "allow",
          "git commit *": "ask",
          "git push *": "deny",
          "grep *": "allow"
        }
      }
    }
  }
}

You can also configure agent permissions in Markdown:

~/.config/opencode/agents/review.md
---
description: Code review without edits
mode: subagent
permission:
  edit: deny
  bash: ask
  webfetch: deny
---

Only analyze code and suggest changes.

Tip

Use pattern matching for commands with arguments. "grep *" allows grep pattern file.txt, while "grep" alone would block it. Commands like git status work for default behavior but require explicit permission (like "git status *") when arguments are passed.




LSP Servers
OpenCode integrates with your LSP servers.

OpenCode integrates with your Language Server Protocol (LSP) to help the LLM interact with your codebase. It uses diagnostics to provide feedback to the LLM.

Built-in
OpenCode comes with several built-in LSP servers for popular languages:

LSP Server	Extensions	Requirements
astro	.astro	Auto-installs for Astro projects
bash	.sh, .bash, .zsh, .ksh	Auto-installs bash-language-server
clangd	.c, .cpp, .cc, .cxx, .c++, .h, .hpp, .hh, .hxx, .h++	Auto-installs for C/C++ projects
csharp	.cs	.NET SDK installed
clojure-lsp	.clj, .cljs, .cljc, .edn	clojure-lsp command available
dart	.dart	dart command available
deno	.ts, .tsx, .js, .jsx, .mjs	deno command available (auto-detects deno.json/deno.jsonc)
elixir-ls	.ex, .exs	elixir command available
eslint	.ts, .tsx, .js, .jsx, .mjs, .cjs, .mts, .cts, .vue	eslint dependency in project
fsharp	.fs, .fsi, .fsx, .fsscript	.NET SDK installed
gleam	.gleam	gleam command available
gopls	.go	go command available
jdtls	.java	Java SDK (version 21+) installed
kotlin-ls	.kt, .kts	Auto-installs for Kotlin projects
lua-ls	.lua	Auto-installs for Lua projects
nixd	.nix	nixd command available
ocaml-lsp	.ml, .mli	ocamllsp command available
oxlint	.ts, .tsx, .js, .jsx, .mjs, .cjs, .mts, .cts, .vue, .astro, .svelte	oxlint dependency in project
php intelephense	.php	Auto-installs for PHP projects
prisma	.prisma	prisma command available
pyright	.py, .pyi	pyright dependency installed
ruby-lsp (rubocop)	.rb, .rake, .gemspec, .ru	ruby and gem commands available
rust	.rs	rust-analyzer command available
sourcekit-lsp	.swift, .objc, .objcpp	swift installed (xcode on macOS)
svelte	.svelte	Auto-installs for Svelte projects
terraform	.tf, .tfvars	Auto-installs from GitHub releases
tinymist	.typ, .typc	Auto-installs from GitHub releases
typescript	.ts, .tsx, .js, .jsx, .mjs, .cjs, .mts, .cts	typescript dependency in project
vue	.vue	Auto-installs for Vue projects
yaml-ls	.yaml, .yml	Auto-installs Red Hat yaml-language-server
zls	.zig, .zon	zig command available
LSP servers are automatically enabled when one of the above file extensions are detected and the requirements are met.

Note

You can disable automatic LSP server downloads by setting the OPENCODE_DISABLE_LSP_DOWNLOAD environment variable to true.

How It Works
When opencode opens a file, it:

Checks the file extension against all enabled LSP servers.
Starts the appropriate LSP server if not already running.
Configure
You can customize LSP servers through the lsp section in your opencode config.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "lsp": {}
}

Each LSP server supports the following:

Property	Type	Description
disabled	boolean	Set this to true to disable the LSP server
command	string[]	The command to start the LSP server
extensions	string[]	File extensions this LSP server should handle
env	object	Environment variables to set when starting server
initialization	object	Initialization options to send to the LSP server
Let’s look at some examples.

Disabling LSP servers
To disable all LSP servers globally, set lsp to false:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "lsp": false
}

To disable a specific LSP server, set disabled to true:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "lsp": {
    "typescript": {
      "disabled": true
    }
  }
}

Custom LSP servers
You can add custom LSP servers by specifying the command and file extensions:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "lsp": {
    "custom-lsp": {
      "command": ["custom-lsp-server", "--stdio"],
      "extensions": [".custom"]
    }
  }
}

Additional Information
PHP Intelephense
PHP Intelephense offers premium features through a license key. You can provide a license key by placing (only) the key in a text file at:

On macOS/Linux: $HOME/intelephense/licence.txt
On Windows: %USERPROFILE%/intelephense/licence.txt
The file should contain only the license key with no additional content.




MCP servers
Add local and remote MCP tools.

You can add external tools to OpenCode using the Model Context Protocol, or MCP. OpenCode supports both local and remote servers.

Once added, MCP tools are automatically available to the LLM alongside built-in tools.

Caveats
When you use an MCP server, it adds to the context. This can quickly add up if you have a lot of tools. So we recommend being careful with which MCP servers you use.

Tip

MCP servers add to your context, so you want to be careful with which ones you enable.

Certain MCP servers, like the GitHub MCP server, tend to add a lot of tokens and can easily exceed the context limit.

Enable
You can define MCP servers in your OpenCode Config under mcp. Add each MCP with a unique name. You can refer to that MCP by name when prompting the LLM.

opencode.jsonc
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "name-of-mcp-server": {
      // ...
      "enabled": true,
    },
    "name-of-other-mcp-server": {
      // ...
    },
  },
}

You can also disable a server by setting enabled to false. This is useful if you want to temporarily disable a server without removing it from your config.

Overriding remote defaults
Organizations can provide default MCP servers via their .well-known/opencode endpoint. These servers may be disabled by default, allowing users to opt-in to the ones they need.

To enable a specific server from your organization’s remote config, add it to your local config with enabled: true:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "jira": {
      "type": "remote",
      "url": "https://jira.example.com/mcp",
      "enabled": true
    }
  }
}

Your local config values override the remote defaults. See config precedence for more details.

Local
Add local MCP servers using type to "local" within the MCP object.

opencode.jsonc
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-local-mcp-server": {
      "type": "local",
      // Or ["bun", "x", "my-mcp-command"]
      "command": ["npx", "-y", "my-mcp-command"],
      "enabled": true,
      "environment": {
        "MY_ENV_VAR": "my_env_var_value",
      },
    },
  },
}

The command is how the local MCP server is started. You can also pass in a list of environment variables as well.

For example, here’s how you can add the test @modelcontextprotocol/server-everything MCP server.

opencode.jsonc
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "mcp_everything": {
      "type": "local",
      "command": ["npx", "-y", "@modelcontextprotocol/server-everything"],
    },
  },
}

And to use it I can add use the mcp_everything tool to my prompts.

use the mcp_everything tool to add the number 3 and 4

Options
Here are all the options for configuring a local MCP server.

Option	Type	Required	Description
type	String	Y	Type of MCP server connection, must be "local".
command	Array	Y	Command and arguments to run the MCP server.
environment	Object		Environment variables to set when running the server.
enabled	Boolean		Enable or disable the MCP server on startup.
timeout	Number		Timeout in ms for fetching tools from the MCP server. Defaults to 5000 (5 seconds).
Remote
Add remote MCP servers by setting type to "remote".

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-remote-mcp": {
      "type": "remote",
      "url": "https://my-mcp-server.com",
      "enabled": true,
      "headers": {
        "Authorization": "Bearer MY_API_KEY"
      }
    }
  }
}

The url is the URL of the remote MCP server and with the headers option you can pass in a list of headers.

Options
Option	Type	Required	Description
type	String	Y	Type of MCP server connection, must be "remote".
url	String	Y	URL of the remote MCP server.
enabled	Boolean		Enable or disable the MCP server on startup.
headers	Object		Headers to send with the request.
oauth	Object		OAuth authentication configuration. See OAuth section below.
timeout	Number		Timeout in ms for fetching tools from the MCP server. Defaults to 5000 (5 seconds).
OAuth
OpenCode automatically handles OAuth authentication for remote MCP servers. When a server requires authentication, OpenCode will:

Detect the 401 response and initiate the OAuth flow
Use Dynamic Client Registration (RFC 7591) if supported by the server
Store tokens securely for future requests
Automatic
For most OAuth-enabled MCP servers, no special configuration is needed. Just configure the remote server:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-oauth-server": {
      "type": "remote",
      "url": "https://mcp.example.com/mcp"
    }
  }
}

If the server requires authentication, OpenCode will prompt you to authenticate when you first try to use it. If not, you can manually trigger the flow with opencode mcp auth <server-name>.

Pre-registered
If you have client credentials from the MCP server provider, you can configure them:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-oauth-server": {
      "type": "remote",
      "url": "https://mcp.example.com/mcp",
      "oauth": {
        "clientId": "{env:MY_MCP_CLIENT_ID}",
        "clientSecret": "{env:MY_MCP_CLIENT_SECRET}",
        "scope": "tools:read tools:execute"
      }
    }
  }
}

Authenticating
You can manually trigger authentication or manage credentials.

Authenticate with a specific MCP server:

Terminal window
opencode mcp auth my-oauth-server

List all MCP servers and their auth status:

Terminal window
opencode mcp list

Remove stored credentials:

Terminal window
opencode mcp logout my-oauth-server

The mcp auth command will open your browser for authorization. After you authorize, OpenCode will store the tokens securely in ~/.local/share/opencode/mcp-auth.json.

Disabling OAuth
If you want to disable automatic OAuth for a server (e.g., for servers that use API keys instead), set oauth to false:

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-api-key-server": {
      "type": "remote",
      "url": "https://mcp.example.com/mcp",
      "oauth": false,
      "headers": {
        "Authorization": "Bearer {env:MY_API_KEY}"
      }
    }
  }
}

OAuth Options
Option	Type	Description
oauth	Object | false	OAuth config object, or false to disable OAuth auto-detection.
clientId	String	OAuth client ID. If not provided, dynamic client registration will be attempted.
clientSecret	String	OAuth client secret, if required by the authorization server.
scope	String	OAuth scopes to request during authorization.
Debugging
If a remote MCP server is failing to authenticate, you can diagnose issues with:

Terminal window
# View auth status for all OAuth-capable servers
opencode mcp auth list

# Debug connection and OAuth flow for a specific server
opencode mcp debug my-oauth-server

The mcp debug command shows the current auth status, tests HTTP connectivity, and attempts the OAuth discovery flow.

Manage
Your MCPs are available as tools in OpenCode, alongside built-in tools. So you can manage them through the OpenCode config like any other tool.

Global
This means that you can enable or disable them globally.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-mcp-foo": {
      "type": "local",
      "command": ["bun", "x", "my-mcp-command-foo"]
    },
    "my-mcp-bar": {
      "type": "local",
      "command": ["bun", "x", "my-mcp-command-bar"]
    }
  },
  "tools": {
    "my-mcp-foo": false
  }
}

We can also use a glob pattern to disable all matching MCPs.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-mcp-foo": {
      "type": "local",
      "command": ["bun", "x", "my-mcp-command-foo"]
    },
    "my-mcp-bar": {
      "type": "local",
      "command": ["bun", "x", "my-mcp-command-bar"]
    }
  },
  "tools": {
    "my-mcp*": false
  }
}

Here we are using the glob pattern my-mcp* to disable all MCPs.

Per agent
If you have a large number of MCP servers you may want to only enable them per agent and disable them globally. To do this:

Disable it as a tool globally.
In your agent config, enable the MCP server as a tool.
opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "my-mcp": {
      "type": "local",
      "command": ["bun", "x", "my-mcp-command"],
      "enabled": true
    }
  },
  "tools": {
    "my-mcp*": false
  },
  "agent": {
    "my-agent": {
      "tools": {
        "my-mcp*": true
      }
    }
  }
}

Glob patterns
The glob pattern uses simple regex globbing patterns:

* matches zero or more of any character (e.g., "my-mcp*" matches my-mcp_search, my-mcp_list, etc.)
? matches exactly one character
All other characters match literally
Note

MCP server tools are registered with server name as prefix, so to disable all tools for a server simply use:

"mymcpservername_*": false

Examples
Below are examples of some common MCP servers. You can submit a PR if you want to document other servers.

Sentry
Add the Sentry MCP server to interact with your Sentry projects and issues.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "sentry": {
      "type": "remote",
      "url": "https://mcp.sentry.dev/mcp",
      "oauth": {}
    }
  }
}

After adding the configuration, authenticate with Sentry:

Terminal window
opencode mcp auth sentry

This will open a browser window to complete the OAuth flow and connect OpenCode to your Sentry account.

Once authenticated, you can use Sentry tools in your prompts to query issues, projects, and error data.

Show me the latest unresolved issues in my project. use sentry

Context7
Add the Context7 MCP server to search through docs.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "context7": {
      "type": "remote",
      "url": "https://mcp.context7.com/mcp"
    }
  }
}

If you have signed up for a free account, you can use your API key and get higher rate-limits.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "context7": {
      "type": "remote",
      "url": "https://mcp.context7.com/mcp",
      "headers": {
        "CONTEXT7_API_KEY": "{env:CONTEXT7_API_KEY}"
      }
    }
  }
}

Here we are assuming that you have the CONTEXT7_API_KEY environment variable set.

Add use context7 to your prompts to use Context7 MCP server.

Configure a Cloudflare Worker script to cache JSON API responses for five minutes. use context7

Alternatively, you can add something like this to your AGENTS.md.

AGENTS.md
When you need to search docs, use `context7` tools.

Grep by Vercel
Add the Grep by Vercel MCP server to search through code snippets on GitHub.

opencode.json
{
  "$schema": "https://opencode.ai/config.json",
  "mcp": {
    "gh_grep": {
      "type": "remote",
      "url": "https://mcp.grep.app"
    }
  }
}

Since we named our MCP server gh_grep, you can add use the gh_grep tool to your prompts to get the agent to use it.

What's the right way to set a custom domain in an SST Astro component? use the gh_grep tool

Alternatively, you can add something like this to your AGENTS.md.

AGENTS.md
If you are unsure how to do something, use `gh_grep` to search code examples from GitHub.




ACP Support
Use OpenCode in any ACP-compatible editor.

OpenCode supports the Agent Client Protocol or (ACP), allowing you to use it directly in compatible editors and IDEs.

Tip

For a list of editors and tools that support ACP, check out the ACP progress report.

ACP is an open protocol that standardizes communication between code editors and AI coding agents.

Configure
To use OpenCode via ACP, configure your editor to run the opencode acp command.

The command starts OpenCode as an ACP-compatible subprocess that communicates with your editor over JSON-RPC via stdio.

Below are examples for popular editors that support ACP.

Zed
Add to your Zed configuration (~/.config/zed/settings.json):

~/.config/zed/settings.json
{
  "agent_servers": {
    "OpenCode": {
      "command": "opencode",
      "args": ["acp"]
    }
  }
}

To open it, use the agent: new thread action in the Command Palette.

You can also bind a keyboard shortcut by editing your keymap.json:

keymap.json
[
  {
    "bindings": {
      "cmd-alt-o": [
        "agent::NewExternalAgentThread",
        {
          "agent": {
            "custom": {
              "name": "OpenCode",
              "command": {
                "command": "opencode",
                "args": ["acp"]
              }
            }
          }
        }
      ]
    }
  }
]

JetBrains IDEs
Add to your JetBrains IDE acp.json according to the documentation:

acp.json
{
  "agent_servers": {
    "OpenCode": {
      "command": "/absolute/path/bin/opencode",
      "args": ["acp"]
    }
  }
}

To open it, use the new ‘OpenCode’ agent in the AI Chat agent selector.

Avante.nvim
Add to your Avante.nvim configuration:

{
  acp_providers = {
    ["opencode"] = {
      command = "opencode",
      args = { "acp" }
    }
  }
}

If you need to pass environment variables:

{
  acp_providers = {
    ["opencode"] = {
      command = "opencode",
      args = { "acp" },
      env = {
        OPENCODE_API_KEY = os.getenv("OPENCODE_API_KEY")
      }
    }
  }
}

CodeCompanion.nvim
To use OpenCode as an ACP agent in CodeCompanion.nvim, add the following to your Neovim config:

require("codecompanion").setup({
  interactions = {
    chat = {
      adapter = {
        name = "opencode",
        model = "claude-sonnet-4",
      },
    },
  },
})

This config sets up CodeCompanion to use OpenCode as the ACP agent for chat.

If you need to pass environment variables (like OPENCODE_API_KEY), refer to Configuring Adapters: Environment Variables in the CodeCompanion.nvim documentation for full details.

Support
OpenCode works the same via ACP as it does in the terminal. All features are supported:

Note

Some built-in slash commands like /undo and /redo are currently unsupported.

Built-in tools (file operations, terminal commands, etc.)
Custom tools and slash commands
MCP servers configured in your OpenCode config
Project-specific rules from AGENTS.md
Custom formatters and linters
Agents and permissions system






Agent Skills
Define reusable behavior via SKILL.md definitions

Agent skills let OpenCode discover reusable instructions from your repo or home directory. Skills are loaded on-demand via the native skill tool—agents see available skills and can load the full content when needed.

Place files
Create one folder per skill name and put a SKILL.md inside it. OpenCode searches these locations:

Project config: .opencode/skills/<name>/SKILL.md
Global config: ~/.config/opencode/skills/<name>/SKILL.md
Project Claude-compatible: .claude/skills/<name>/SKILL.md
Global Claude-compatible: ~/.claude/skills/<name>/SKILL.md
Understand discovery
For project-local paths, OpenCode walks up from your current working directory until it reaches the git worktree. It loads any matching skills/*/SKILL.md in .opencode/ and any matching .claude/skills/*/SKILL.md along the way.

Global definitions are also loaded from ~/.config/opencode/skills/*/SKILL.md and ~/.claude/skills/*/SKILL.md.

Write frontmatter
Each SKILL.md must start with YAML frontmatter. Only these fields are recognized:

name (required)
description (required)
license (optional)
compatibility (optional)
metadata (optional, string-to-string map)
Unknown frontmatter fields are ignored.

Validate names
name must:

Be 1–64 characters
Be lowercase alphanumeric with single hyphen separators
Not start or end with -
Not contain consecutive --
Match the directory name that contains SKILL.md
Equivalent regex:

^[a-z0-9]+(-[a-z0-9]+)*$

Follow length rules
description must be 1-1024 characters. Keep it specific enough for the agent to choose correctly.

Use an example
Create .opencode/skills/git-release/SKILL.md like this:

---
name: git-release
description: Create consistent releases and changelogs
license: MIT
compatibility: opencode
metadata:
  audience: maintainers
  workflow: github
---

## What I do

- Draft release notes from merged PRs
- Propose a version bump
- Provide a copy-pasteable `gh release create` command

## When to use me

Use this when you are preparing a tagged release.
Ask clarifying questions if the target versioning scheme is unclear.

Recognize tool description
OpenCode lists available skills in the skill tool description. Each entry includes the skill name and description:

<available_skills>
  <skill>
    <name>git-release</name>
    <description>Create consistent releases and changelogs</description>
  </skill>
</available_skills>

The agent loads a skill by calling the tool:

skill({ name: "git-release" })

Configure permissions
Control which skills agents can access using pattern-based permissions in opencode.json:

{
  "permission": {
    "skill": {
      "*": "allow",
      "pr-review": "allow",
      "internal-*": "deny",
      "experimental-*": "ask"
    }
  }
}

Permission	Behavior
allow	Skill loads immediately
deny	Skill hidden from agent, access rejected
ask	User prompted for approval before loading
Patterns support wildcards: internal-* matches internal-docs, internal-tools, etc.

Override per agent
Give specific agents different permissions than the global defaults.

For custom agents (in agent frontmatter):

---
permission:
  skill:
    "documents-*": "allow"
---

For built-in agents (in opencode.json):

{
  "agent": {
    "plan": {
      "permission": {
        "skill": {
          "internal-*": "allow"
        }
      }
    }
  }
}

Disable the skill tool
Completely disable skills for agents that shouldn’t use them:

For custom agents:

---
tools:
  skill: false
---

For built-in agents:

{
  "agent": {
    "plan": {
      "tools": {
        "skill": false
      }
    }
  }
}

When disabled, the <available_skills> section is omitted entirely.

Troubleshoot loading
If a skill does not show up:

Verify SKILL.md is spelled in all caps
Check that frontmatter includes name and description
Ensure skill names are unique across all locations
Check permissions—skills with deny are hidden from agents






Custom Tools
Create tools the LLM can call in opencode.

Custom tools are functions you create that the LLM can call during conversations. They work alongside opencode’s built-in tools like read, write, and bash.

Creating a tool
Tools are defined as TypeScript or JavaScript files. However, the tool definition can invoke scripts written in any language — TypeScript or JavaScript is only used for the tool definition itself.

Location
They can be defined:

Locally by placing them in the .opencode/tools/ directory of your project.
Or globally, by placing them in ~/.config/opencode/tools/.
Structure
The easiest way to create tools is using the tool() helper which provides type-safety and validation.

.opencode/tools/database.ts
import { tool } from "@opencode-ai/plugin"

export default tool({
  description: "Query the project database",
  args: {
    query: tool.schema.string().describe("SQL query to execute"),
  },
  async execute(args) {
    // Your database logic here
    return `Executed query: ${args.query}`
  },
})

The filename becomes the tool name. The above creates a database tool.

Multiple tools per file
You can also export multiple tools from a single file. Each export becomes a separate tool with the name <filename>_<exportname>:

.opencode/tools/math.ts
import { tool } from "@opencode-ai/plugin"

export const add = tool({
  description: "Add two numbers",
  args: {
    a: tool.schema.number().describe("First number"),
    b: tool.schema.number().describe("Second number"),
  },
  async execute(args) {
    return args.a + args.b
  },
})

export const multiply = tool({
  description: "Multiply two numbers",
  args: {
    a: tool.schema.number().describe("First number"),
    b: tool.schema.number().describe("Second number"),
  },
  async execute(args) {
    return args.a * args.b
  },
})

This creates two tools: math_add and math_multiply.

Arguments
You can use tool.schema, which is just Zod, to define argument types.

args: {
  query: tool.schema.string().describe("SQL query to execute")
}

You can also import Zod directly and return a plain object:

import { z } from "zod"

export default {
  description: "Tool description",
  args: {
    param: z.string().describe("Parameter description"),
  },
  async execute(args, context) {
    // Tool implementation
    return "result"
  },
}

Context
Tools receive context about the current session:

.opencode/tools/project.ts
import { tool } from "@opencode-ai/plugin"

export default tool({
  description: "Get project information",
  args: {},
  async execute(args, context) {
    // Access context information
    const { agent, sessionID, messageID } = context
    return `Agent: ${agent}, Session: ${sessionID}, Message: ${messageID}`
  },
})

Examples
Write a tool in Python
You can write your tools in any language you want. Here’s an example that adds two numbers using Python.

First, create the tool as a Python script:

.opencode/tools/add.py
import sys

a = int(sys.argv[1])
b = int(sys.argv[2])
print(a + b)

Then create the tool definition that invokes it:

.opencode/tools/python-add.ts
import { tool } from "@opencode-ai/plugin"

export default tool({
  description: "Add two numbers using Python",
  args: {
    a: tool.schema.number().describe("First number"),
    b: tool.schema.number().describe("Second number"),
  },
  async execute(args) {
    const result = await Bun.$`python3 .opencode/tools/add.py ${args.a} ${args.b}`.text()
    return result.trim()
  },
})

Here we are using the Bun.$ utility to run the Python script.